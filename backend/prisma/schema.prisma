generator client {
  provider = "prisma-client-js"
}

datasource db {
  provider  = "postgresql"
  url       = env("DATABASE_URL")
  directUrl = env("DIRECT_URL")
}

/// ///////////////////////////////////////////////////
/// ///////////////////////////////////////////////////
model User {
  id                  String                @id @default(uuid())
  email               String                @unique
  password            String?
  name                String
  phoneE164           String?
  roles               Role[]
  isActive            Boolean               @default(true)
  createdAt           DateTime              @default(now())
  updatedAt           DateTime              @updatedAt
  emailVerified       DateTime?
  image               String?
  accounts            Account[]
  assignments         Assignment[]
  availability        Availability[]
  defaultAssignments  DefaultAssignment[]
  leaderRotations     LeaderRotation[]
  notifications       NotificationLog[]
  passwordResetTokens PasswordResetToken[]
  servicesLed         Service[]             @relation("LeaderServices")
  sessions            Session[]
  setSongsAsSinger    SetSong[]             @relation("SetSongSinger")
  singerSongKeys      SingerSongKey[]       @relation("SingerKeys")
  songProgress        UserSetSongProgress[]
  suggestionSlots     SuggestionSlot[]
  userInstruments     UserInstrument[]
  worshipSetsLed      WorshipSet[]          @relation("WorshipSetLeader")
}

/// ///////////////////////////////////////////////////
/// ///////////////////////////////////////////////////
model ServiceType {
  id                 String              @id @default(uuid())
  name               String              @unique
  defaultStartTime   String
  rrule              String?
  defaultAssignments DefaultAssignment[]
  leaderRotations    LeaderRotation[]
  services           Service[]
}

model Service {
  id            String        @id @default(uuid())
  serviceTypeId String
  serviceDate   DateTime
  leaderId      String?
  status        ServiceStatus @default(planned)
  leader        User?         @relation("LeaderServices", fields: [leaderId], references: [id])
  serviceType   ServiceType   @relation(fields: [serviceTypeId], references: [id], onDelete: Cascade)
  worshipSet    WorshipSet?

  @@unique([serviceTypeId, serviceDate])
  @@index([serviceDate])
}

model WorshipSet {
  id              String           @id @default(uuid())
  serviceId       String           @unique
  status          SetStatus        @default(draft)
  suggestDueAt    DateTime?
  notes           String?
  leaderUserId    String?
  assignments     Assignment[]
  setSongs        SetSong[]
  suggestionSlots SuggestionSlot[]
  leaderUser      User?            @relation("WorshipSetLeader", fields: [leaderUserId], references: [id])
  service         Service          @relation(fields: [serviceId], references: [id], onDelete: Cascade)
}

/// ///////////////////////////////////////////////////
/// ///////////////////////////////////////////////////
model Song {
  id                String          @id @default(uuid())
  title             String
  artist            String?
  ccliNumber        String?
  defaultYoutubeUrl String?
  tags              String[]
  language          String?
  familiarityScore  Int             @default(50)
  isActive          Boolean         @default(true)
  createdAt         DateTime        @default(now())
  updatedAt         DateTime        @updatedAt
  singerSongKeys    SingerSongKey[]
  versions          SongVersion[]
  suggestions       Suggestion[]

  @@index([title])
}

model SongVersion {
  id         String      @id @default(uuid())
  songId     String
  name       String
  youtubeUrl String?
  defaultKey String?
  bpm        Int?
  notes      String?
  setSongs   SetSong[]
  song       Song        @relation(fields: [songId], references: [id], onDelete: Cascade)
  chordSheet ChordSheet?
}

model ChordSheet {
  id            String   @id @default(uuid())
  songVersionId String   @unique
  chordText     String?
  originalKey   String?
  fileUrl       String?
  fileName      String?
  externalUrl   String?
  createdAt     DateTime @default(now())
  updatedAt     DateTime @updatedAt

  songVersion   SongVersion @relation(fields: [songVersionId], references: [id], onDelete: Cascade)
}

model SetSong {
  id                 String                @id @default(uuid())
  setId              String
  songVersionId      String
  position           Int
  keyOverride        String?
  youtubeUrlOverride String?
  isNew              Boolean               @default(false)
  notes              String?
  singerId           String?
  worshipSet         WorshipSet            @relation(fields: [setId], references: [id], onDelete: Cascade)
  singer             User?                 @relation("SetSongSinger", fields: [singerId], references: [id])
  songVersion        SongVersion           @relation(fields: [songVersionId], references: [id], onDelete: Cascade)
  userProgress       UserSetSongProgress[]

  @@unique([setId, position])
}

/// Tracks whether a user has listened to a song for practice
model UserSetSongProgress {
  id         String   @id @default(uuid())
  userId     String
  setSongId  String
  listenedAt DateTime @default(now())
  createdAt  DateTime @default(now())

  user    User    @relation(fields: [userId], references: [id], onDelete: Cascade)
  setSong SetSong @relation(fields: [setSongId], references: [id], onDelete: Cascade)

  @@unique([userId, setSongId])
  @@index([userId])
  @@index([setSongId])
}

/// Tracks which key a singer uses for a particular song (full history)
model SingerSongKey {
  id          String   @id @default(uuid())
  singerId    String
  songId      String
  key         String
  serviceDate DateTime
  notes       String?
  createdAt   DateTime @default(now())
  singer      User     @relation("SingerKeys", fields: [singerId], references: [id], onDelete: Cascade)
  song        Song     @relation(fields: [songId], references: [id], onDelete: Cascade)

  @@index([singerId, songId])
  @@index([singerId])
  @@index([songId])
}

/// ///////////////////////////////////////////////////
/// ///////////////////////////////////////////////////
model SuggestionSlot {
  id             String       @id @default(uuid())
  setId          String
  assignedUserId String
  minSongs       Int
  maxSongs       Int
  dueAt          DateTime
  status         SlotStatus   @default(pending)
  suggestions    Suggestion[]
  assignedUser   User         @relation(fields: [assignedUserId], references: [id], onDelete: Cascade)
  worshipSet     WorshipSet   @relation(fields: [setId], references: [id], onDelete: Cascade)
}

model Suggestion {
  id                 String           @id @default(uuid())
  slotId             String
  songId             String
  youtubeUrlOverride String?
  notes              String?
  createdAt          DateTime         @default(now())
  status             SuggestionStatus @default(pending)
  suggestionSlot     SuggestionSlot   @relation(fields: [slotId], references: [id], onDelete: Cascade)
  song               Song             @relation(fields: [songId], references: [id], onDelete: Cascade)
}

/// ///////////////////////////////////////////////////
/// ///////////////////////////////////////////////////
model Instrument {
  id                 String              @id @default(uuid())
  code               String              @unique
  displayName        String
  maxPerSet          Int
  assignments        Assignment[]
  defaultAssignments DefaultAssignment[]
  userInstruments    UserInstrument[]
}

model UserInstrument {
  id               String       @id @default(uuid())
  userId           String
  instrumentId     String
  proficiencyLevel Proficiency?
  isPrimary        Boolean      @default(false)
  createdAt        DateTime     @default(now())
  updatedAt        DateTime     @updatedAt
  instrument       Instrument   @relation(fields: [instrumentId], references: [id], onDelete: Cascade)
  user             User         @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([userId, instrumentId])
  @@index([userId])
  @@index([instrumentId])
}

model DefaultAssignment {
  id            String      @id @default(uuid())
  serviceTypeId String
  instrumentId  String
  userId        String
  instrument    Instrument  @relation(fields: [instrumentId], references: [id], onDelete: Cascade)
  serviceType   ServiceType @relation(fields: [serviceTypeId], references: [id], onDelete: Cascade)
  user          User        @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([serviceTypeId, instrumentId])
}

model Assignment {
  id           String           @id @default(uuid())
  setId        String
  instrumentId String
  userId       String
  status       AssignmentStatus @default(invited)
  invitedAt    DateTime?
  respondedAt  DateTime?
  instrument   Instrument       @relation(fields: [instrumentId], references: [id], onDelete: Cascade)
  worshipSet   WorshipSet       @relation(fields: [setId], references: [id], onDelete: Cascade)
  user         User             @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([setId, instrumentId, userId])
}

/// ///////////////////////////////////////////////////
/// ///////////////////////////////////////////////////
model Availability {
  id     String   @id @default(uuid())
  userId String
  start  DateTime
  end    DateTime
  notes  String?
  user   User     @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@index([userId, start, end])
}

model LeaderRotation {
  id            String      @id @default(uuid())
  userId        String
  serviceTypeId String
  rotationOrder Int
  isActive      Boolean     @default(true)
  createdAt     DateTime    @default(now())
  updatedAt     DateTime    @updatedAt
  serviceType   ServiceType @relation(fields: [serviceTypeId], references: [id], onDelete: Cascade)
  user          User        @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([serviceTypeId, rotationOrder])
  @@index([serviceTypeId, isActive])
}

model NotificationLog {
  id          String   @id @default(uuid())
  userId      String
  channel     Channel
  templateKey String
  payloadJson Json
  sentAt      DateTime
  status      String
  user        User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

/// ///////////////////////////////////////////////////
/// ///////////////////////////////////////////////////
model Account {
  id                String  @id @default(uuid())
  userId            String
  type              String
  provider          String
  providerAccountId String
  refresh_token     String?
  access_token      String?
  expires_at        Int?
  token_type        String?
  scope             String?
  id_token          String?
  session_state     String?
  user              User    @relation(fields: [userId], references: [id], onDelete: Cascade)

  @@unique([provider, providerAccountId])
}

model Session {
  id           String   @id @default(uuid())
  sessionToken String   @unique
  userId       String
  expires      DateTime
  user         User     @relation(fields: [userId], references: [id], onDelete: Cascade)
}

model VerificationToken {
  identifier String
  token      String   @unique
  expires    DateTime

  @@unique([identifier, token])
}

model PasswordResetToken {
  id        String    @id @default(uuid())
  token     String    @unique
  userId    String
  expiresAt DateTime
  usedAt    DateTime?
  createdAt DateTime  @default(now())
  user      User      @relation(fields: [userId], references: [id], onDelete: Cascade)
}

/// ///////////////////////////////////////////////////
/// ///////////////////////////////////////////////////
enum Role {
  admin
  leader
  musician
}

enum ServiceStatus {
  planned
  published
  cancelled
}

enum SetStatus {
  draft
  collecting
  selecting
  published
  locked
}

enum SlotStatus {
  pending
  submitted
  missed
}

enum SuggestionStatus {
  pending
  approved
  rejected
}

enum AssignmentStatus {
  invited
  accepted
  declined
  withdrawn
}

enum Proficiency {
  beginner
  intermediate
  advanced
}

enum Channel {
  email
  sms
}
